# Lab 6 树基础

## A

遍历叶子节点

之前一直WA是因为潜意思认为第一个是父节点 第二个是子节点

想一想这个错误似乎看来上个学期就犯过的说..人类果然是复读机…

正确的做法是计算每个节点的度 如果度为1的就认为是叶子节点

当然在极端情况下（回落成链表） 根节点也会被判定为叶子节点 这里要加一个特判

 

## B

树的遍历..

TODO: 用二叉树特性补全？

 

## C

堆的基本实现

坑：两个子节点可能超出界限 需要另外检测

在删除节点的时候 从上往下调整 每次都是把最小的换到上边

 

 

## D

图上最远距离 不保证二叉树

分治：最远=左子树最远+右子树最远

遍历：先找到离root最远的点I 再找离i最远的点j

先找最远点l：先序遍历 每次记录距离 子节点就是父节点距离+1 看情况更新

证明：反证法：根在最长链上 根不在最长链上

[实际上不需要存所有的I 任何一个都是可以的]

 

代码注：

注意和A一样 input给的只是边 没有给出父节点和子节点 需要通过一个rootno手动判定

注意到 在找j的时候 需要对i做提根操作 本质上就是把i作为新的根 所有的操作都是一样的 代码基本上不用改… 这里或许可以做一些简化

 

 D做法2

对根节点来说 最长边有两种可能情况

1 最长边经过根节点 那么maxL = leftMax + rightMAX + 2（左子树和右子树连回根）

2 最长边不经过根节点 那么maxL就是子树的maxL

主方法：动态规划

 

更新maxL? （已知的最远距离）

检查子节点 两个最长枝 所有枝（maxD）中最长的两个 的和+2

和 每个单独子节点的maxL 的最大值

 

更新maxD? （最大枝）

选择两个所有子节点中maxD最大的那个 然后+1

 

从顶层递归开始

注意防止回倒（加参数parent）



## E

理论上来说似乎是手写堆

但是我自己的手写堆超时了

最后还是上的TreeMap

 

E姚老师修正版

之前超时的问题：如果遇到了之前买过的商品 需要先在堆里找到 然后更新visited属性 然后维护一次它在堆中的位置

如果单纯在数组里寻找 时间复杂度On会被T

如果利用TreeSet 那么就可以用Olgn 找到 这种情况下是没问题的

姚老师的想法：旧的信息就扔在里面 直接把新的信息压到堆里 然后在delete的时候再判定

具体判定：1 检查是否存在于当前口袋中 2 检查visited次数是不是最新的 3 检查putop（放入时间）是不是最新的

如果判定失败了 就再从里边取 一直到判定成功为止

这样的话 就完全不需要搜索的过程 只是取出的时候可能需要多取几次

代码实现：在外边用两个HashMap存储visited和putop信息 每次更新的时候同步更新 取出的时候检查

 

## F

先手必输：对称（真实对称/对称的延伸：层数相同）

结论

所有深度相同的视作一层

对每一层 黑色节点个数都是偶数 那么先手必输

其他情况下先手必赢

 

## G

神秘代码 HDOJ 5325

先把题目翻译下

1 hongset内部要求联通

2 从ui到ui+1 路径上所有点的权重都比w小

第一个要求很好满足 只要在树上遍历的时候不要跳过节点就好了

第二个操作就麻烦一点 反正我自己没想出来 看题解才知道…

思路就是把这棵树转换成一个有向图 图上从权值小的点指向权值大的点 然后找到能展开最大范围的节点 读出这个节点的size值 （从这个结点出发能到达的节点的个数 包括自己）

为什么这个思路可以？把权值最小的节点想象成山谷 比它权值高的节点都是山峰

第二个要求 实际上就是从一个山峰开始出发 先一路下行 回到山谷 然后再一路上行到更高的另一座山峰

只要是这样走的路径 就一定能满足第二个要求

在理解了思路之后 这道题就变成了两个部分

1 把树转换成有向图 2 计算每个结点的size值

第一部分的操作可以直接在读取输入的时候进行 对每个节点有一个List来存储其指向的节点（方向向外 out） 然后每次读到一条边 检查哪边是权值较小的端点 然后就把大端点加到小端点的list中 全部读完 也就建立好了图

第二部分就麻烦一些 需要用dfs（深度优先搜索）的思想 不过也可以这样想：

对于当前节点 检查它向外指的所有节点（list中的节点）如果是已经算过size 那就把外层节点的size加到自己的size上 如果没有算过size 那就让外层节点先算size 算完再进行加的操作

这样每个节点只会产生一次计算 大大减少了计算量

最后遍历所有结点的size 输出最大的那个就完成了

 

这道题如果用java实现似乎会遇到语言的坑

如果自定义了node对象 在使用最优算法（上述）的前提下 依然会被T

但是如果直接开数组 就能过 时间在2000ms

个人猜测是对象开销的问题 可能测试数据过强 以至于光是对象本身的开销就能导致超时了…

看来还是要学习一波 多用其他语言写程序 不能总是依赖于java…

 

 