# Lab 4 栈&队列

## A

简单题

lanran上一个指针 输入字符串上一个指针 如果遇到相同字符就前进一格 什么时候lanran都走完了就成功了

## B

简单题 模板题

TB上课讲的…从左到右扫描 左括号入栈 遇到右括号检查是否栈顶是对应的括号

## C

虽然明面上是三元组 实际上只需要考虑做右端点 中间直接排列组合就好

可以用快慢指针 也可以用队列来处理

不过需要用数列相加公式 单纯循环容易T

## D

注意到总共也就24种可能情况 暴力就好

## E

栈+贪心？

目标：每次都输出尽可能小（满足字典序的定义）

-> 相当于每次都尝试输出当前剩余的最小值（要么在栈顶 要么在最后）

![1545999050081](C:\Users\jerry\AppData\Roaming\Typora\typora-user-images\1545999050081.png)

## F

本质上就是个大模拟...

优先级顺序：左括号 乘 加 右括号

套了一个矩阵外壳的表达式求值问题

思路很清晰：先tokenize输入的表达式 得到中缀表达式 再转换成后缀表达式 再对后缀表达式求值（也可以用双栈法直接求）

Tokenize/parse的时候可以用Java自带的StringTokenizer 也可以去手写【可能有坑：负数问题】

求值的时候注意最好所有都开long 不然最后可能WA

后缀表达式求值需要注意从栈中弹出来的顺序是和操作符顺序相反的 需要倒过来 尤其是在减和乘的时候

## G

既然我们关心的就是每一步的最大最小值 因此用两个栈 对于每一次push 存入当前的最大最小值 pop的时候直接先把两个栈pop一次再peek即可

（两个栈就足够了）