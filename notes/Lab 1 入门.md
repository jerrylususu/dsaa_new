# Lab 1 入门

这个是入门lab 所以相对而言有点点水

## A

检测字符串出现 大小写不敏感

先全部转成小写 然后跑一个find就行...

## B

经典的汉诺塔问题 但是有一些小修改 不能直接从A到C

原版递推公式：$$T(n+1) = T(n) + 1 + T(n) = 2 \cdot T(n)+1$$

新版递推公式：$$T(n+1)=3\cdot T(n)+2$$

（做法：先把上层从A->B->C 底层A->B 上层C->B->A 底层 B->C 上层 A->B->C）

写个while计算就好了

## C

有点诡异的博弈

除非Alice第一步就下了(1,1) 不然Alice必定不会输

解释：（credit to 姚老师）

首先一个规律：对于完全信息博弈 要么先手必赢 要么先手必输（围棋也是完全信息博弈 但是当前的人类找不到最优策略 不能确定是先手必赢还是先手必输）

对于我们这个例子 考虑一个局面 仅仅关心(1,1)到(m,n)的部分

注意到 除了落在(m,n) 上 落在此范围内的任何一个其他点都会包含(m,n)

所以(m,n)实际上是一个无效点 原本的先手可以通过落在这个无效点上变成后手

因此如果这个游戏是先手必胜 那么先手直接就能获胜

如果是先手必败 那么先手中途可以通过落在一个无效点上转换为后手 从而利用先手必输的策略获胜

总而言之 先手必胜 （除非先手自杀）

## D

打印图形...

注意：先准备画布 再分别操作每个面 这样相对容易思考一些

## E

找两个数之间的最大差异

考虑到数据量级在1e5 如果单纯对每对数进行遍历 运算量在1e10 超出1e8的一秒运算量 所以暴力估计会T

优化：动态规划：每次新加入的数 可能能作为当前的最大值 也可能能扩大当前的最大差值

```java
int max=arr[0],max_diff=Integer.MIN_VALUE;
for(int i=1;i<size;i++){
	if(max-arr[i]>max_diff){
		max_diff=max-arr[i];
    }
	if(arr[i]>max){
		max=arr[i];
	}
}
```

## F

先说说题意可能的误解：要求的是对整个字符串的全局操作（如果把S改成大写  所有S都要改）

因此 对于例子2 consonants 结果是2而不是3

想法1：直接把不可用的字母作为分隔符 然后计算中间可用字符串

这个思路是不可行的 因为无法考虑全局操作导致的影响

想法2：暴力变换 每次改变某些字母的大小写 然后统计

这个思路也不可行 因为复杂度太高 直接T了 但是已经摸到边了

正确想法：先预处理 获得当前的字母组合的统计信息 然后进行**二进制遍历** 对所有出现过的字母的大小写组合进行遍历 同时利用之前预处理得到的信息直接计算 （不用再先生成字符串后计算）

具体的统计信息：某组合(a,b)的出现次数

## G

这个就纯粹是智力题了 找所有可能的长方体展开图 最后统计出展开后长和宽不同的一共有8组 然后都试试看就好了

具体请直接搜索"长方体遍历"



