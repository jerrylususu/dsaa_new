# Lab 5 字符串

## A

直接比较最后一个字符... 记录下最大值 很直接..

## B

从\*的地方断开 分别检查前缀和后缀 

分成*在前 *在后 *在中间三种情况

## C

字符串搜索 直接上KMP把 或者FSA也行

先预处理建立next数组 然后开始跑 同时计数就好

## D

题目：找出现在给定字符串首、尾、中间的最长的字符串

首先跑一边KMP 利用next数组的性质读出最多有多少位前缀=后缀（实际上就是next数组最后一位的值）

然后在字符串中间尝试跑KMP 如果存在就输出 不存在就减少一位再试

## E

一个字符串的前缀是一个字符串的后缀

直接把第二个字符串翻转过来 然后一位位跑...

## F

求多个字符串的最长公共子串 原题 POJ 3080

首先注意到 每个字符串最多长200 为暴力提供了可能

最后的做法是暴力+剪枝

首先从所有的输入字符串中选一个最短的作为起始点

然后把这个字符串的所有可能的子字符串划分找出来 （暴力）

然后对于每个子字符串划分 建立next数组 然后在其他剩余的字符串上跑 一旦存在一个失败就把这个字符串跳过 （剪枝）

最后把所有通过的子字符串排序 选最长的那个就好了

## G

噩梦... WA穿了

原题：2018牛客网暑期ACM 第九场F Typing practice

这题可以用KMP 也可以用FSA 不过最简单的还是FSA

KMP的话需要对4个给定串分别跑KMP 利用最后一个字符的性质 （Word+"分隔符"+Op 拼接）

FSA就好很多 用4个栈分别记录每个给定字符串上的状态 遇到-回退就好了