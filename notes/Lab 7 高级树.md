# Lab 7 高级树

## ABC

判断

判断是不是完全二叉树

判断是不是BST

判断是不是AVL



## A

这题全tm是坑！！！

第1个节点未必是根节点

我自己的做法：1 找根 2 写深度 3 逐层水平遍历判断

1 找根：节点加上parent属性 然后一个while回溯

2 写深度：单纯的向下递归 顺便传个数组记录每一层节点个数 一个boolean看是否越界

这两个结论可以提前判断

3 水平遍历：我自己的实现是BFS 先用一个栈

然后每一层从左到右加入 检查是否符合预期深度 还有是否应该有左右子节点

 

李老师修正

水平遍历

如果遇到了一个空节点 但是后面又遇到非空节点 那么就肯定是不行的

注意每层需要重置marker

(层序遍历 遇到非满二叉树结点的时候 检查队列中剩下的是不是叶子节点）

 

```
A测试数据

4
5
2 3 
4 0
5 0
0 0
0 0
5
3 4
0 0
2 5
0 0
0 0
5
2 3
0 0
0 0
1 5
0 0
3
2 0
0 0
1 0

N
Y
Y
N

```



## B

先看是不是二叉树

然后看根在哪里

-> 中序遍历满足升序

建立树的时候需要注意左右儿子的顺序问题

（处理爆栈：中序遍历非递归实现）

方法：没啥特殊 中序遍历用非递归实现就行

（非递归中序遍历思想：先找到当前的最左下的节点 中间过程存在栈里

找到了之后输出 然后开始回溯到父节点 再找右节点 然后在开始找左下

一直到这个过程完成）

复习 考试肯定要考 （还有前中后）

 

## C

AVL树根本特征：左右子树最多高差为1

判断二叉树  （已经是左右儿子了 肯定是）

找根节点

用6D的方式判断：递归判定

可以在判断深度的时候设定下返回值 顺带设定左右子树深度

返回的是当前节点的深度（max(left,right)+1)

但是光用深度判定肯定是不够的 依然还需要一次中缀遍历来判定

 

## D

堆排序

先判定需要小根堆还是大根堆

根据K建立相应大小的堆

然后每次维护的时候 先拿出顶上的节点 然后把下一个换到顶上 再做shiftdown

**堆的空间复杂度分析 O(k+(n-k)log k)???**

 

做题笔记

问题也就是pq过不去 需要用自己写的堆

一个小麻烦可能是怎么让自己写的最小堆同时兼容最大堆

解法1 写个interface 然后实现一个最小版本和最大版本

解法2 写个能传入构造器作为参数的泛型堆实现

注：需要用快读

 

### 一类问题：求一个数列中前K大/小的数

建立一个小根堆/大根堆 先把前K个数放进去

对于后面的数 如果大于/小于堆顶 就取出堆顶 把新数放进去

这样全部走完就可以得到了



## E

冒泡排序

每一轮都是把当前没有排序的部分的最大值浮到最后

优先队列

大概是用堆实现一个优先队列 基于最大堆 最小堆

如果输入K 那么先popK次 把结果从尾部往前面放 这样最后K个值一定是有序的 符合冒泡排序的结论

然后就是按照输入队列的顺序把数字从堆里边提出来 然后从数组前面往后面放

**复杂度：建堆K 后面k次delete操作 每次logK?**

 

两种可行方法：

方法1 建立大小为k+1的小根堆 在size<k的时候一直加 然后扫到下一个 先加入 然后把堆顶放到result数组中

方法2 建立大小为k+1的小根堆 先一直加满 扫到下一个 先把堆顶放到result数组中 然后再加入下一个

为什么这两个解法都是可行的？

冒泡排序的特点：数字最多前移1格 但是后移的个数不限

因此在k次冒泡排序之后 原来小的数字会前移k格 大的数字则会一路到最后（即最后k个数一定是有序的）

基于这个思想 可以看作每次都是在吸收当前已知的最大k个 每次吸入之后都把当前的堆顶放下

两种方法都是基于这个思路实现的 虽然开始放下的时间不一样 本质上结果也是一样的 

法1中 在i=k+1的时候开始先加入 再放下 后续的值显然是堆中的最小值（堆顶）

法2中 在i=k+2的时候开始先放下 再加入 后续的值也是上一个时刻中堆中的最小值

由此可知 两种方法的结果必然是相同的

 

本题的坑

1 不仅要快读 而且要快写（调用out 而不是System.out)

2 PQ不是万能的 需要自己实现堆才能过（不知道怎么卡的数据）

3 如果想要更快 建堆的时候可以用rootfix的On方法

 

```
E 测试数据
2

5 1
5 4 3 2 1

5
2
3 8 3 2 4

43215
32348

```



## F

BST -> BBST / AVL

找第k大：每个节点记录size

避免每次遍历整个树：存储一个相对值（当前工资-基准值）

一开始基准值设成0 如果+10 基准-10 / 如果所有人-20 基准+20

 

解题记录：

很有收获的一道题目…

基本思路是先写BST 然后改成AVL 

然后改成带size的AVL （需要访问第k大）

最后改成带count的AVL （可能含有重复的工资）

 

BST基本没啥问题 可以参考《数据结构与算法》Java版本上的BST实现

但是注意需要对root进行特判 以此来保证修改也会作用回root上

以及大部分用递归实现的方法都需要有一个只有输入，没有节点作为参数的重载方法 方便外界进行调用

 

AVL就麻烦一些 需要处理平衡 也就是左右旋的问题

可以参考这个博客：https://www.cnblogs.com/skywang12345/p/3577479.html#a2

具体而言 在每次insert/remove操作之后 在递归返回的时候需要检查层级高度 如果高度出错了就需要进行旋转

旋转完之后需要进行结算 重新计算当前节点的Height

坑1 单旋转和双旋转并不是单纯根据插入方向判定的 而是需要访问子层节点来选择

（有一个很奇怪的问题 为什么一定是要大于等于 而不能单纯大于

解释：大于等于的话 高度相等的情况就会进行双旋转 但是双旋转需要多访问一层 可能会NPE

但是如果进行单旋转 就能保证所有节点都存在

注释：这个依照具体实现 也可以加特判来解决这个问题）

坑2 用getHeight方法来包裹null 但是updateHeight需要独立出来 get和update操作需要先后进行

坑3 在单双旋转具体实现中 节点k1 k2 k3的height/size计算顺序需要从下层到上层



然后就是改成带size的AVL树 同时实现findKth方法

加size没啥困难 基本上哪里有height修改 就要有相应的size修改

不过height是max(l,r)+1 size就直接是l+r+1就好了

一个相对麻烦的地方是findKth的具体实现 需要用纸笔仔细计算下什么时候向左 什么时候向右

肯定是用递归 然后用一个cnt来存储当前已经跳过了多少个比预期小的节点



最后提交的时候发现WA了 原来工资是可以重复的

应对方法也很简单 每个节点加上count属性 初始值设为1

Insert/remove的时候如果key相同 就检查count是不是1

不是说明有重复节点 直接count--就好 如果是1才说明就只有一个 正常删除就好

注意这里对count的判定要连带上整个tree的size（其实也可以不用 毕竟根节点的size会自动刷新）

然后因为count的加入 存在重复节点 所以每个节点的size也需要修改 原来的+1需要变成+count

最后就是重新实现findKth 这个更烦人了…不过还是纸笔讨论一下就好

 

总而言之 很有收获的一个题目…

AVL树和代码实现能力还需要再加强就是了…

 

## G

给一个数列 从某个数开始 跳一个步长 问新生成数列中第k大

 

习题课思路：离线处理

对每个步长都先处理好 然后缓存 在后面输入query的时候直接从已经计算好的缓存中读取就好

 

实际实现挺多坑的…

 

首先是如何效率最优的构造缓存

选择底层结构：因为上一题的影响 我这里一开始用的是树 但是实际上因为是找固定的第k大 所以一个大小为k的最小堆就够用了

判定合法条件：1<=step<=n, size = (n-x)/y+1>=k, size>=k （k=sqrt(n)下取整）

这里的思路是倒过来 正常的是给start和step 然后从前往后算 但这样每次都需要重建堆

所以应该从数组的尾部出发 往前倒着计算 一直到抵达数组头部为止

外层的循环是step 内层是type（从倒数第1个，倒数第2个…倒数第k个开始回倒）

然后把每次先把当前值arr[cursor]和堆的最小值比较 看要不要放入堆 

再把堆的最小值peek()出来 存到储存的数组中

（这里不知道为什么 用hashmap会超时 不得已改了数组）

 

这样缓存就构造完了 但是这样依然会TLE

下一步优化是针对后边的query的 对query进行统计 只计算query中含有的step

 

双管齐下应该就没问题了

 

后续记录：不需要快读 pq可过 

补充：可以只计算x%y（只计算需要的type）